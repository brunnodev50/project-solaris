<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Genesis Engine - Solaris | Brunno H. V. Boas</title>
    <style>
        :root {
            --primary-color: #ff9d00;
            --text-shadow: 0 0 10px rgba(255, 157, 0, 0.5);
        }
        * { margin:0; padding:0; box-sizing: border-box; }
        html, body { 
            height:100%; 
            background:#000; 
            overflow:hidden; 
            font-family: 'Inter', sans-serif;
        }
        canvas { 
            width:100%; 
            height:100%; 
            display:block; 
            position:fixed; 
            top:0; 
            left:0; 
            z-index: 1;
        }
        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        /* Header Area */
        .header {
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
            background: linear-gradient(to right, #fff, var(--primary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header .subtitle {
            font-size: 0.8rem;
            font-weight: 300;
            letter-spacing: 0.1rem;
            color: #ccc;
            margin-top: 0.2rem;
            opacity: 0.8;
        }

        /* Footer / Author Area */
        .footer {
            text-align: right;
            color: white;
        }
        .footer .dev-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
            color: #888;
            margin-bottom: 0.3rem;
        }
        .footer .author-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.1rem;
            text-transform: uppercase;
            color: #fff;
            border-right: 3px solid var(--primary-color);
            padding-right: 10px;
            text-shadow: var(--text-shadow);
        }
        
        /* Loading / Instructions */
        .instructions {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            color: rgba(255,255,255,0.4);
            font-size: 0.75rem;
            letter-spacing: 0.05rem;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&display=swap" rel="stylesheet">
</head>
<body>

    <div class="ui-layer">
        <div class="header">
            <h1>Solaris</h1>
            <div class="subtitle">GENESIS ENGINE V.2.0</div>
        </div>
        
        <div class="instructions">
            DRAG TO ORBIT â€¢ SCROLL TO ZOOM
        </div>

        <div class="footer">
            <div class="dev-label">Lead Developer</div>
            <div class="author-name">Brunno Henrique Vilas Boas</div>
        </div>
    </div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

// Setup Renderer
const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance', stencil: false, depth: true });
const DPR = Math.min(window.devicePixelRatio || 1, 2);
renderer.setPixelRatio(DPR);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 1);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15; // Slightly increased exposure
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

// Camera
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
camera.position.set(0, 20, 90);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; 
controls.dampingFactor = 0.05;
controls.minDistance = 25; 
controls.maxDistance = 200;
controls.autoRotate = true; // Added auto rotation
controls.autoRotateSpeed = 0.3;

// Colors Palette
const COLORS = {
  core:   new THREE.Color(1.00, 0.85, 0.60),
  shell:  new THREE.Color(1.00, 0.45, 0.05), // More intense orange
  diskA:  new THREE.Color(1.00, 0.65, 0.10),
  diskB:  new THREE.Color(0.98, 0.20, 0.05),
  ring:   new THREE.Color(1.00, 0.45, 0.15),
  emberA: new THREE.Color(1.00, 0.90, 0.70),
  emberB: new THREE.Color(1.00, 0.40, 0.00),
  prominence: new THREE.Color(1.00, 0.55, 0.10)
};

// GLSL Noise Utilities
const noiseFunctions = /* glsl */`
  vec3 mod289(vec3 x){return x - floor(x*(1.0/289.0))*289.0;}
  vec4 mod289(vec4 x){return x - floor(x*(1.0/289.0))*289.0;}
  vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
  float snoise(vec3 v){
    const vec2 C=vec2(1.0/6.0,1.0/3.0);
    const vec4 D=vec4(0.0,0.5,1.0,2.0);
    vec3 i=floor(v+dot(v,C.yyy));
    vec3 x0=v-i+dot(i,C.xxx);
    vec3 g=step(x0.yzx,x0.xyz);
    vec3 l=1.0-g;
    vec3 i1=min(g.xyz,l.zxy);
    vec3 i2=max(g.xyz,l.zxy);
    vec3 x1=x0-i1+C.xxx;
    vec3 x2=x0-i2+C.yyy;
    vec3 x3=x0-D.yyy;
    i=mod289(i);
    vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
    float n_=0.142857142857;
    vec3 ns=n_*D.wyz-D.xzx;
    vec4 j=p-49.0*floor(p*ns.z*ns.z);
    vec4 x_=floor(j*ns.z);
    vec4 y_=floor(j-7.0*x_);
    vec4 x=x_*ns.x+ns.yyyy;
    vec4 y=y_*ns.x+ns.yyyy;
    vec4 h=1.0-abs(x)-abs(y);
    vec4 b0=vec4(x.xy,y.xy); vec4 b1=vec4(x.zw,y.zw);
    vec4 s0=floor(b0)*2.0+1.0; vec4 s1=floor(b1)*2.0+1.0;
    vec4 sh=-step(h,vec4(0.0));
    vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy; vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
    vec3 p0=vec3(a0.xy,h.x); vec3 p1=vec3(a0.zw,h.y); vec3 p2=vec3(a1.xy,h.z); vec3 p3=vec3(a1.zw,h.w);
    vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
    p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
    vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
    m=m*m;
    return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
  }
`;

const coreGroup = new THREE.Group();
scene.add(coreGroup);

// --- SUN CORE ---
const starGeometry = new THREE.IcosahedronGeometry(4, 6); // Higher detail
const starMaterial = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 }, uCore: { value: COLORS.core } },
  vertexShader: `
    uniform float time;
    varying vec3 vN;
    varying float vDisp;
    ${noiseFunctions}
    void main(){
      vN = normalize(normal);
      float n1 = snoise(normal * 2.5 + time * 0.5);
      float n2 = snoise(normal * 5.0 - time * 0.2);
      vDisp = n1 * 0.6 + n2 * 0.4; // Layered noise
      vec3 newPosition = position + normal * (vDisp * 0.3);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
    }
  `,
  fragmentShader: `
    uniform float time; 
    uniform vec3 uCore; 
    varying vec3 vN;
    varying float vDisp;
    ${noiseFunctions}
    void main(){
      // Complex pulsing/plasma effect
      float pulse = 0.5 + 0.5 * sin(time * 1.5);
      float fres = pow(1.0 - abs(dot(vN, vec3(0,0,1))), 2.5);
      
      // Hot spots based on displacement
      float hotSpot = smoothstep(0.2, 0.8, vDisp);
      vec3 hotColor = vec3(1.0, 1.0, 0.9);
      
      vec3 base = uCore * (0.6 + 2.0 * fres);
      vec3 finalCol = mix(base, hotColor, hotSpot * 0.4);
      
      gl_FragColor = vec4(finalCol, 1.0);
    }
  `,
  blending: THREE.AdditiveBlending, depthWrite: false
});
coreGroup.add(new THREE.Mesh(starGeometry, starMaterial));

// --- SUN SHELL/CORONA ---
const shellGeometry = new THREE.IcosahedronGeometry(8.2, 5);
const shellMaterial = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 }, uShell: { value: COLORS.shell } },
  vertexShader: `
    uniform float time;
    varying vec3 vN; 
    varying vec2 vUv;
    varying vec3 vPos;
    ${noiseFunctions}
    void main(){ 
      vN = normalize(normal); 
      vUv = uv;
      vPos = position;
      float displacement = snoise(position * 1.2 + time * 0.3) * 1.2;
      vec3 newPosition = position + normal * displacement;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0); 
    }
  `,
  fragmentShader: `
    uniform float time; 
    uniform vec3 uShell; 
    varying vec3 vN; 
    varying vec2 vUv;
    varying vec3 vPos;
    ${noiseFunctions}
    void main(){
      float fres = pow(1.0 - abs(dot(vN, vec3(0,0,1))), 0.8);
      float n = snoise(vec3(vUv * 6.0, time * 0.3));
      
      // Turbulent flows
      float flow = snoise(vPos * 0.2 + vec3(0, time, 0));
      
      float intensity = (0.2 + 0.8 * fres) * (0.8 + 0.2 * n) * (1.0 + 0.3 * flow);
      
      vec3 color = uShell * intensity * 1.5;
      float alpha = clamp(fres * 0.8, 0.0, 0.6); // Slightly clearer
      gl_FragColor = vec4(color, alpha);
    }
  `,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.BackSide
});
coreGroup.add(new THREE.Mesh(shellGeometry, shellMaterial));

// --- ACCRETION RINGS ---
const ringGeom = new THREE.TorusGeometry(60, 2.5, 4, 128);
const ringMat = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 }, uRing: { value: COLORS.ring } },
  vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
  fragmentShader: `
    uniform float time; 
    uniform vec3 uRing; 
    varying vec2 vUv;
    ${noiseFunctions}
    void main() {
      float n1 = snoise(vec3(vUv.x * 12.0 - time * 0.2, vUv.y * 4.0, time * 0.1));
      float n2 = snoise(vec3(vUv.x * 8.0 + time * 0.1, vUv.y * 2.0, 0.0));
      float combined = smoothstep(0.4, 0.7, n1) * 0.7 + smoothstep(0.3, 0.6, n2) * 0.3;
      gl_FragColor = vec4(uRing * (0.8 + combined), combined * 0.5);
    }
  `,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
});
const ring1 = new THREE.Mesh(ringGeom, ringMat);
ring1.rotation.x = Math.PI * 0.52;
scene.add(ring1);

// --- PARTICLE FIELD ---
const particleCount = 25000;
const diskPositions = new Float32Array(particleCount * 3);
const diskSeeds = new Float32Array(particleCount);
const diskBands = new Float32Array(particleCount);
for (let i = 0; i < particleCount; i++) {
  const r = 12 + Math.random()*45; // Wider spread
  const theta = Math.random()*Math.PI*2;
  // Spiral distribution
  diskPositions[i*3]     = Math.cos(theta)*r;
  diskPositions[i*3 + 1] = (Math.random() - 0.5) * (r * 0.15); // More vertical height further out
  diskPositions[i*3 + 2] = Math.sin(theta)*r;
  diskSeeds[i] = Math.random()*1000.0;
  diskBands[i] = (r - 12.0) / 45.0;
}
const diskGeom = new THREE.BufferGeometry();
diskGeom.setAttribute('position', new THREE.BufferAttribute(diskPositions, 3));
diskGeom.setAttribute('aSeed', new THREE.BufferAttribute(diskSeeds, 1));
diskGeom.setAttribute('aBand', new THREE.BufferAttribute(diskBands, 1));
const diskMat = new THREE.ShaderMaterial({
  uniforms: { uColorA: { value: COLORS.diskA }, uColorB: { value: COLORS.diskB }, time: { value: 0 } },
  vertexShader: `
    uniform float time; 
    attribute float aSeed; 
    attribute float aBand;
    varying float vMix; 
    varying float vAlpha;
    vec2 rot(vec2 p, float a){ float c=cos(a), s=sin(a); return vec2(c*p.x - s*p.y, s*p.x + c*p.y); }
    void main(){
      vec3 p = position;
      float r = length(p.xz);
      float speed = (20.0 / max(10.0, r)); // Keplerian-ish motion
      float angle = -time * speed * 0.05;
      p.xz = rot(p.xz, angle);
      
      // Undulation
      p.y += sin(time * 1.5 + r * 0.5 + aSeed) * 0.5;
      
      vec4 mvp = modelViewMatrix * vec4(p, 1.0);
      gl_Position = projectionMatrix * mvp;
      
      // Size depends on band and distance
      gl_PointSize = (60.0 / -mvp.z) * (0.5 + 0.5 * (1.0 - aBand));
      vMix = aBand;
      vAlpha = 0.3 + 0.5 * sin(time * 2.0 + aSeed);
    }
  `,
  fragmentShader: `
    uniform vec3 uColorA; 
    uniform vec3 uColorB; 
    varying float vMix; 
    varying float vAlpha;
    void main(){
      if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard;
      vec3 col = mix(uColorA, uColorB, vMix + 0.2 * sin(vMix*10.0));
      gl_FragColor = vec4(col, vAlpha);
    }
  `,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
});
scene.add(new THREE.Points(diskGeom, diskMat));

// --- PROMINENCES (Solar Flares) ---
const prominenceCount = 1200; // More density
const prominencePos = new Float32Array(prominenceCount * 3);
const prominenceSeeds = new Float32Array(prominenceCount * 4);
for (let i = 0; i < prominenceCount; i++) {
    prominencePos.set([0, 0, 0], i * 3);
    prominenceSeeds.set([Math.random(), 0.1 + Math.random() * 0.5, 5.0 + Math.random() * 20.0, 0.5 + Math.random()], i * 4);
}
const prominenceGeom = new THREE.BufferGeometry();
prominenceGeom.setAttribute('position', new THREE.BufferAttribute(prominencePos, 3));
prominenceGeom.setAttribute('aSeed', new THREE.BufferAttribute(prominenceSeeds, 4));
const prominenceMat = new THREE.ShaderMaterial({
    uniforms: { uColor: { value: COLORS.prominence }, time: { value: 0 } },
    vertexShader: `
      uniform float time;
      attribute vec4 aSeed;
      varying float vLife;
      vec4 quat_from_axis_angle(vec3 axis, float angle) {
          vec4 qr;
          float half_angle = (angle * 0.5);
          qr.x = axis.x * sin(half_angle);
          qr.y = axis.y * sin(half_angle);
          qr.z = axis.z * sin(half_angle);
          qr.w = cos(half_angle);
          return qr;
      }
      vec3 rotate_vertex_position(vec3 position, vec4 q) {
          return position + 2.0 * cross(q.xyz, cross(q.xyz, position) + q.w * position);
      }
      void main() {
          float life = mod(time * aSeed.y * 0.5 + aSeed.x, 1.0); // Faster flares
          vLife = life;
          float arc = sin(life * 3.14159);
          vec3 p = vec3(0.0, arc * aSeed.z, (life - 0.5) * 18.0);
          vec3 axis = normalize(vec3(aSeed.x - 0.5, aSeed.y - 0.5, aSeed.z - 0.5));
          vec4 q = quat_from_axis_angle(axis, aSeed.x * 6.28318);
          p = rotate_vertex_position(p, q);
          p += normalize(p) * 6.0;
          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_PointSize = (180.0 / -mvPosition.z) * arc * aSeed.w;
          gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      varying float vLife;
      void main() {
          if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard;
          gl_FragColor = vec4(uColor, 0.8 * sin(vLife * 3.14159));
      }
    `,
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
});
coreGroup.add(new THREE.Points(prominenceGeom, prominenceMat));

// --- BACKGROUND STARS (Twinkling) ---
{
  const count = 4000;
  const pos = new Float32Array(count * 3);
  const phases = new Float32Array(count);
  for (let i=0;i<count;i++){
    const r = THREE.MathUtils.randFloat(300, 1500);
    const th = Math.random()*Math.PI*2;
    const ph = Math.acos(THREE.MathUtils.randFloatSpread(2));
    pos[i*3]   = r * Math.sin(ph) * Math.cos(th);
    pos[i*3+1] = r * Math.cos(ph);
    pos[i*3+2] = r * Math.sin(ph) * Math.sin(th);
    phases[i] = Math.random() * Math.PI * 2;
  }
  const bgGeom = new THREE.BufferGeometry();
  bgGeom.setAttribute('position', new THREE.BufferAttribute(pos,3));
  bgGeom.setAttribute('aPhase', new THREE.BufferAttribute(phases,1));
  
  const bgMat = new THREE.ShaderMaterial({
    uniforms: { time: { value: 0 } },
    vertexShader: `
      attribute float aPhase;
      varying float vAlpha;
      uniform float time;
      void main(){
         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
         gl_Position = projectionMatrix * mvPosition;
         gl_PointSize = (300.0 / length(mvPosition.xyz));
         // Twinkle calc
         vAlpha = 0.3 + 0.7 * (0.5 + 0.5 * sin(time * 2.0 + aPhase));
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      void main(){
         if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard;
         gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha);
      }
    `,
    transparent: true, depthWrite: false
  });
  scene.add(new THREE.Points(bgGeom, bgMat));
}

// --- POST PROCESSING ---
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

// Afterimage (Motion blur trails) - Tuned down from 0.92 to 0.85 for cleaner look
const afterimagePass = new AfterimagePass(0.85);
composer.addPass(afterimagePass);

// Bloom
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.1); // Stronger bloom
composer.addPass(bloomPass);

// FXAA (Anti-aliasing)
const fxaaPass = new ShaderPass(FXAAShader);
fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * DPR);
fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * DPR);
composer.addPass(fxaaPass);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
  fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
});

// Animation Loop
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const time = clock.getElapsedTime();
  
  // Uniform Updates
  starMaterial.uniforms.time.value = time;
  shellMaterial.uniforms.time.value = time;
  diskMat.uniforms.time.value = time;
  ringMat.uniforms.time.value = time;
  prominenceMat.uniforms.time.value = time;
  scene.children[scene.children.length-1].material.uniforms.time.value = time; // BG Stars

  // Dynamic Bloom Pulse
  const pulse = 0.5 + 0.5 * Math.sin(time * 0.8);
  bloomPass.strength = 1.2 + 0.3 * pulse;

  // Rotations
  coreGroup.rotation.y -= delta * 0.02;
  
  controls.update();
  composer.render();
}

animate();
</script>
</body>
</html>